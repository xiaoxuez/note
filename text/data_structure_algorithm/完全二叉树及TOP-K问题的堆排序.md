## 完全二叉树、Top K的堆排序



#### 准备知识：

+ 完全二叉树的定义

  若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。(注意的是，树的概念里节点是从1开始，数组的概念里是从0开始)

+ 完全二叉树的特性：

  -  叶子节点只可能出现在最大的两层上，对任意节点，其右分支下的子孙最大层次为L，其左分支下的子孙的最大层次必为L或L+1（左右子树的深度不会超过1）
  - 出于简便起见，完全二叉树通常采用数组来存储。（注意，以下假设数组是从1开始，而不是从0）
  - 完全二叉树第i层至多有2^（i-1）个节点，共i层的完全二叉树最多有2^i-1个节点。
  - 对于完全二叉树的数组t[i]， len为数组长度，数组下标从0开始，有如下特性：
    + 若i>1, 则t[i]的父节点为t[i/2]。
    + 相反，若t[i]的左子树和右子树分别为2\*i和2\*i+1，当然前提是2\*i和2\*i+1 < len
    + 对应，若i<(n-1)/2，那么t[i]必有2个孩子

+ 堆的定义：堆是一种完全二叉树或者近似完全二叉树，所以效率极高





#### 算法题

+ 堆排序

  所谓堆排序就是利用堆这种数据结构来对数组排序，分为最大堆和最小堆。最大堆的任意子树根节点不小于任意子结点，最小堆的根节点不大于任意子结点。

  下面采用最大堆的实现举例，最小堆也是一样。

  再强调一下，最大堆中，任意父节点大于其子节点。那么结论是最顶部的根节点的值是最大的。

  堆排序的实现分为两步，其一是构造堆，构造的堆满足父节点大于子节点；再则是排序，实现数组的有序性。

  那...

  我要开始表演了！

  ```
  //1. 从最后一个父节点开始，依次往前，调整所有父节点和子节点的关系，让每一个父节点都大于其任意子节点
  //2. 构建好了堆，构建的好的堆应该是根节点是最大的，任意父节点大于其子节点的值,然后问题就是，构建好的堆是部分有序的，父节点大于子节点，现在问题就是全部有序，思路就是，堆的根节点是所有的最大值，那么得到一个最大值，然后再把根节点空出来，然后再进行堆构建，每次出最大值，进行N次，那么最后出来的就是有序的,空出来的选择是，每次把最后一个和根节点互换，每次堆构建的长度减1，就跟选择排序一样，每次出一个最大值，下次选择就少比较一个
  func buildHeap(s []int) {
  	length := len(s)
  	//最后一个数为
  	last := length - 1
  	//最后一个父节点(last - 1) / 2
  	for i := (last - 1) / 2; i >= 0; i-- {
  		maxHeap(s, i, length)
  	}
  	//构建好堆进行堆排序
  	for last > 0 {
  		swap(s, 0, last)
  		maxHeap(s, 0, last)
  		last--
  	}
  }

  func maxHeap(s []int, father, len int) {
  	//调整父节点下所有len之类的子节点的，达到father下满足父节点大于子节点
  	sonLeft := father*2 + 1
  	sonRight := father*2 + 2

  	max := father
  	if sonLeft < len {
  		//找出大的子节点K
  		k := sonLeft
  		if sonRight < len && s[sonRight] > s[sonLeft] {
  			k = sonRight
  		}
  		//若子节点比父节点大
  		if s[k] > s[father] {
  			max = k
  		}
  	}
  	if max != father {
  		swap(s, father, max)
  		maxHeap(s, max, len)
  	}
  }
  ```

  ​


+ TOP N

  有N(N>>10000)个整数,求出其中的前K个最大的数

  这个问题的解答为构建长度为K的最小堆，根节点为最小的值，后续加入的数先跟根节点进行比较，若比根节点大，则替换成根节点后构建最小堆，构建完成后依然根节点为最小值，再比较...